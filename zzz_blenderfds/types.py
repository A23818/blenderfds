"""BlenderFDS, types"""

from bpy.props import *
from bpy.types import Scene, Object, Material

from .exceptions import BFException
from .utils import is_iterable, ClsList

from . import config

DEBUG = True

### Collections

def subscribe(cls):
    """Subscribe class to related collections."""
    # Transform self.bf_props from List to ClsList
    cls.bf_props = ClsList(cls.bf_props)
    # Subscribe to class collection 'self.all'
    cls.all.append(cls)
    # Subscribe to other useful dicts, but init specific dict for each new class
    # Build my cls.all_bf_props
    cls.all_bf_props = ClsList()
    if cls.bf_prop_export: cls.all_bf_props.append(cls.bf_prop_export)
    for bf_prop in cls.bf_props:
        cls.all_bf_props.append(bf_prop)
        cls.all_bf_props.extend(bf_prop.all_bf_props)
    # Return
    return cls

# BFProp and BFNamelist are used for short lived instances.
# When calling a Blender Element bf_namelist or bf_namelists method,
# the BFNamelist and all related BFProps are instantiated, then quickily forgotten
# This mechanism is used to draw panels and to export to FDS.

#@subscribe This will be used to subscribe the class to the collections
class _BFCommon():
    """Common part of BFProp and BFNamelist"""

    all = ClsList()           # Collection of all classes of my type
                              # Generated by @subscribe decorator, inited on class type
    all_bf_props = ClsList()  # Collection of all my managed bf_props, included descendants
                              # Generated by @subscribe decorator, inited on each class

    label = "No Label"        # Object label
    description = "No desc"   # Object description
    enum_id = 0               # Unique integer id for EnumProperty
    fds_label = None          # FDS label as "OBST", "ID", ...

    bf_prop_export = None     # Class of type BFExportProp, used for setting if exported
    bf_props =  ClsList()     # Collection of related BFProp

    bf_other = {}             # Other optional BlenderFDS parameters,
                              # eg: {'copy_protection': True, 'draw_type': 'WIRE', 'hide_select': True, ...}

    bpy_type = None           # type in bpy.types for Blender property, eg. Object
    bpy_idname = None         # idname of related bpy.types Blender property, eg. "bf_id"
    bpy_prop = None           # prop in bpy.props of Blender property, eg. StringProperty
    bpy_other = {}            # Other optional Blender property parameters,
                              # eg. {"min": 3., "default": 0., ...}

    def __init__(self, element):
        # The instance contains the reference to element
        self.element = element
        # Replace linked BFProp classes with their instances
        if self.bf_prop_export: self.bf_prop_export = self.bf_prop_export(element)
        if self.bf_props: self.bf_props = ClsList((bf_prop(element) for bf_prop in self.bf_props))
        # Init exporting variables
        self.infos = list()

    def __repr__(self):
        return "{__class__.__name__!s}(element={element!r})".format(
            __class__ = self.__class__, **self.__dict__)
    
    # Generated properties
    
    @property
    def bf_prop_free(self):
        for bf_prop in self.bf_props:
            if isinstance(bf_prop, BFFreeProp): return bf_prop

    @property
    def bf_prop_XB(self):
        for bf_prop in self.bf_props:
            if isinstance(bf_prop, BFXBProp): return bf_prop

    @property
    def bf_prop_XYZ(self):
        for bf_prop in self.bf_props:
            if isinstance(bf_prop, BFXYZProp): return bf_prop
            
    @property
    def bf_prop_PB(self):
        for bf_prop in self.bf_props:
            if isinstance(bf_prop, BFPBProp): return bf_prop

    # Register/Unregister

    @classmethod
    def register(cls):
        """Register all related Blender properties."""
        DEBUG and print("BFDS: BFProp.register:", cls.__name__)
        if not cls.bpy_type: raise Exception("No bpy_type in class '{}'".format(str(cls)))
        # Register my own Blender property, if needed
        if cls.bpy_prop and cls.bpy_idname and not hasattr(cls.bpy_type, cls.bpy_idname):
            if DEBUG:
                print("BFDS:  ", '{}.{} = {}(name="{}")'.format(
                    cls.bpy_type.__name__,
                    cls.bpy_idname,
                    cls.bpy_prop.__name__,
                    cls.label
                ))
            setattr(
                cls.bpy_type,
                cls.bpy_idname,
                cls.bpy_prop(name=cls.label, description=cls.description, **cls.bpy_other)
            )

    @classmethod
    def unregister(cls):
        """Unregister all related Blender properties."""
        DEBUG and print("BFDS: BFProp.unregister:", str(cls)) # TODO unregister

    # UI

    def _draw_messages(self, context, layout) -> "None":
        """Draw messages."""
        # Check self and trap errors
        try: self.check(context) 
        except BFException as err: err.draw(context, layout)
        # Draw infos
        for info in self.infos:
            if is_iterable(info):
                row = layout.split(.7)
                row.label(icon="INFO", text=info[0])
                row.operator(info[1])
            else:
                layout.label(icon="INFO", text=info)

    # Check

    def check(self, context):
        """Check self, append str infos to self.infos, on error raise BFException."""
        pass

    # Export

    def get_value(self) -> "any or None":
        """Get my Blender property value for element."""
        # None is not accepted as attribute name, replaced with str()
        return getattr(self.element, self.bpy_idname or str(), None)

    def set_value(self, context, value) -> "any or None":
        """Set my Blender property to value for element."""
        # Do not raise BFException here. Check is performed by UI, do not add overhead!
        if self.bpy_idname: setattr(self.element, self.bpy_idname, value)
        
    def set_default_value(self, context) -> "any or None":
        """Set my Blender property to default value for element."""
        default = self.bpy_other.get("default")
        if default is not None: self.set_value(context, default)

    def get_exported(self, context) -> "bool":
        """Return True if self is exported to FDS."""
        if self.bf_prop_export: return self.bf_prop_export.get_value()
        return True

    def set_exported(self, context, value) -> "any or None":
        """Set to value if self is exported to FDS."""
        if self.bf_prop_export: self.bf_prop_export.set_value(context, value)

    def set_default(self, context) -> "any or None":
        """Set me to default for element."""
        self.set_default_value(context)
        for bf_prop in self.all_bf_props:
            bf_prop(self.element).set_default_value(context) # Instantiate!


class BFProp(_BFCommon):
    """BlenderFDS property, interface between a Blender property and an FDS parameter."""
       
    all = ClsList() # Re-init to obtain specific collection
    all_bf_props = ClsList()

    def __str__(self):
        return "{} > Parameter {}".format(
            str(self.element),
            self.fds_label or self.label or self.__name__,
            )

    # UI

    def _transform_layout(self, context, layout) -> "layout":
        """If self has a bf_prop_export, prepare double-column Blender panel layout."""
        layout = layout.row()
        if self.bf_prop_export:
            # Set two distinct colums: layout_export and layout_ui
            layout_export, layout = layout.column(), layout.column()
            layout_export.prop(self.element, self.bf_prop_export.bpy_idname, text="")
        else:
            layout = layout.column()
        layout.active = bool(self.get_exported(context)) # if not exported, layout is inactive. Protect it from None
        return layout

    def _draw_body(self, context, layout) -> "None":
        """Draw bpy_prop"""
        if not self.bpy_idname: return
        row = layout.row()
        row.prop(self.element, self.bpy_idname, text=self.label)

    def draw(self, context, layout) -> "None":
        """Draw my part of Blender panel."""
        layout = self._transform_layout(context, layout)
        self._draw_body(context, layout)
        self._draw_messages(context, layout)

    # Export

    def format(self, context, value):
        """Format to FDS notation."""
        # Expected output:
        #   ID='example' or PI=3.14 or COLOR=3,4,5
        if value is None: return None
        # If value is not an iterable, then put it in a tuple
        if not is_iterable(value): values = tuple((value,)) 
        else: values = value
        # Check first element of the iterable and choose formatting
        if   isinstance(values[0], bool):
            value = ",".join(value and ".TRUE." or ".FALSE." for value in values)
        elif isinstance(values[0], int):
            value = ",".join(str(value) for value in values)
        elif isinstance(values[0], float):
            value = ",".join("{:.{}f}".format(value, self.bpy_other.get("precision",3)) for value in values)
        elif isinstance(values[0], str) and value: # value is not ""
            value = ",".join("'{}'".format(value) for value in values)
        else:
            return None
        # Return
        if self.fds_label: return "=".join((self.fds_label, value))
        return str(value)

    def to_fds(self, context) -> "str":
        """Get my exported FDS string, on error raise BFException."""
        if not self.get_exported(context): return None
        self.check(context)
        value = self.get_value()
        return self.format(context, value)

    # Import

    def from_fds(self, context, value):
        """Set my value from value in FDS notation, on error raise BFException.
        Value is any type of data compatible with bpy_prop
        Eg: "String", (0.2,3.4,1.2), ...
        """
        # DEBUG and print("BFDS: BFProp.from_fds:", str(self), value)
        self.set_exported(context, True)
        try: self.set_value(context, value)
        except: raise BFException(self, "Error importing '{}' value".format(value))


class BFNamelist(_BFCommon):
    """BlenderFDS namelist, interface between a Blender object and an FDS namelist."""
       
    all = ClsList() # Re-init to obtain specific collection
    all_bf_props = ClsList()

    def __str__(self):
        return "{} > Namelist {}".format(
            str(self.element),
            self.fds_label or self.label or self.__name__,
            )
    
    # UI

    @classmethod
    def get_enum_item(cls) -> "List":
        """Get item for EnumProperty items."""
        return (
            cls.__name__,
            "{} ({})".format(cls.label, cls.description),
            cls.description,
            cls.enum_id
        )

    def draw_header(self, context, layout):
        """Draw Blender panel header."""
        if self.bf_prop_export: layout.prop(self.element, self.bf_prop_export.bpy_idname, text="")
        if self.description: return "BlenderFDS {} ({})".format(self.label, self.description)
        return "BlenderFDS {}".format(self.label)

    def _transform_layout(self, context, layout) -> "layout":
        """If self has a bf_prop_export, prepare Blender panel layout."""
        layout.active = self.get_exported(context)
        return layout

    def _draw_bf_props(self, context, layout):
        """Draw bf_props"""
        for bf_prop in self.bf_props or tuple(): bf_prop.draw(context, layout)

    def draw(self, context, layout) -> "None":
        """Draw my part of Blender panel."""
        layout = self._transform_layout(context, layout)
        self._draw_messages(context, layout)
        self._draw_bf_props(context, layout)

    # Export

    def format(self, context, params):
        """Format to FDS notation."""
        # Expected output:
        # ! name: info message 1
        # ! name: info message 2
        # &OBST ID='example' XB=... /\n
        # &OBST ID='example' XB=... /\n

        # Set separator
        separator = config.namelist_separator
        # Set fds_label, if empty use first param (OP_free_namelist)
        fds_label = "".join(("&", self.fds_label or params.pop(0), " "))
        # Set info
        infos = [is_iterable(info) and info[0] or info for info in self.infos]
        info = "".join(("! {}\n".format(info) for info in infos))
        # Extract the first and only multiparams from params
        multiparams = None
        for param in params:
            if is_iterable(param):
                multiparams = param
                params.remove(param)
                # ... then remove ordinary single ID
                for param in params:
                    if param[:3] == "ID=":
                        params.remove(param)
                        break
                break
        # ... and join remaining params + namelist closure
        params.append("/\n")
        param = separator.join(params)
        # Build namelists, set body
        # &fds_label multiparam param /
        if multiparams:
            body = "".join((
                separator.join(("".join((fds_label, multiparam)), param)) for multiparam in multiparams
            ))
        else:
            body = "".join((fds_label, param))
        # Return
        return "".join((info, body))

    def to_fds(self, context) -> "str":
        """Get my exported FDS string, on error raise BFException."""
        DEBUG and print("BFDS: BFNamelist.to_fds:", str(self))
        # Check self
        if not self.get_exported(context): return None
        self.check(context)
        # Check and eval my bf_props
        params = list()
        errors = list()
        # Export my bf_props
        for bf_prop in self.bf_props or tuple():
            try: param = bf_prop.to_fds(context)
            except BFException as err: errors.append(err)
            else:
                if param: params.append(param)
                self.infos.extend(bf_prop.infos)
        # Re-raise occurred errors
        if errors: raise BFException(self, "Following errors reported", errors)
        # Return
        return self.format(context, params)

    # Import

    def from_fds(self, context, tokens) -> "None":
        """Set my properties from imported FDS tokens, on error raise BFException.
        Tokens have the following format: ((fds_original, fds_label, fds_value), ...)
        Eg: (("ID='example'", "ID", "example"), ("XB=...", "XB", (1., 2., 3., 4., 5., 6.,)), ...)
        """
        DEBUG and print("BFDS: BFNamelist.from_fds:", str(self), tokens)
        # Init
        if not tokens: return
        # Set separator
        separator = config.namelist_separator
        # Only scene namelists may be overwritten;
        # Do not mix old and new properties, so first set default, if it exists
        if self.bpy_type == Scene: self.set_default(context)
        # Set export of myself
        self.set_exported(context, True)
        # Order tokens, SURF_ID needs a working mesh, so treat last, after XB, XYZ, PB* that create the mesh
        tokens.sort(key=lambda k:k[1]==("SURF_ID")) # Order is: False then True
        # Treat tokens
        free_texts = list()
        errors = list()
        for token in tokens:
            # Init
            fds_original, fds_label, fds_value = token
            # Search managed FDS property, and import token
            bf_prop_cls = self.all_bf_props.get_by_fds_label(fds_label)
            if bf_prop_cls:
                # This FDS property is managed: instantiate and import BFProp
                try: bf_prop_cls(self.element).from_fds(context, fds_value)
                except BFException as err: errors.append(err)
            else:
                # This FDS property is not managed
                free_texts.append(fds_original)
        # Save unmanaged tokens in self.bf_prop_free
        if free_texts and self.bf_prop_free:
            self.bf_prop_free.set_value(context, " ".join(free_texts))
        # Re-raise occurred errors
        if errors: raise BFException(self, "Following errors reported", errors)

### Specialized BFProp

class BFStringProp(BFProp):
    """This specialized BFProp is used as type for single string properties."""
    bpy_prop = StringProperty
    bpy_other =  {
        "maxlen": 32,
        "default": "",
    }

    def check(self, context):
        value = self.get_value()
        if '&' in value or '/' in value:
            raise BFException(self, "& and / characters not allowed")
        if "'" in value or '"' in value or "`" in value or "“" in value \
            or "”" in value or "‘" in value or "’‌" in value:
            raise BFException(self, "Quote characters not allowed")

    def format(self, context, value):
        if value:
            if self.fds_label: return "{}='{}'".format(self.fds_label, value)
            else: return str(value)


class BFBoolProp(BFProp):
    """This specialized BFProp is used as type for bool properties,
    that should not be exported when their value is the same as FDS default.
    """
    bpy_prop = BoolProperty
    bpy_other =  {
        "default": False,
    }

    def get_exported(self, context):
        if self.bf_prop_export: return self.bf_prop_export.get_value()
        if self.get_value() == self.bpy_other.get("default"): return False
        return True    
        

class BFExportProp(BFProp):
    """This specialized BFProp is used as type for exporting properties."""
    label = "Export"
    description = "Set if exported to FDS"
    bpy_type = None # Remember to setup!
    bpy_idname = "bf_export"
    bpy_prop = BoolProperty
    bpy_other = {
        "default": False,
    }


class BFFYIProp(BFStringProp):
    """This specialized BFProp is used as type for FYI properties."""
    label = "FYI"
    description = "Description, for your information"
    fds_label = "FYI"
    bpy_type = None # Remember to setup!
    bpy_idname = "bf_fyi"
    bpy_prop = StringProperty
    bpy_other =  {
        "maxlen": 128,
        "default": "",
    }

    def _draw_body(self, context, layout):
        row = layout.row()
        row.prop(self.element, self.bpy_idname, text="", icon="INFO")


class BFFreeProp(BFProp):
    """This specialized BFProp is used as type for Free parameters properties."""
    label = "Free parameters"
    description = "Free parameters, use matched single quotes as string delimiters, eg <P1='example' P2=1,2,3>"
    bpy_type = None # Remember to setup!
    bpy_idname = "bf_free"
    bpy_prop = StringProperty
    bpy_other =  {
        "maxlen": 1024,
        "default": "",
    }

    def check(self, context):
        value = self.get_value()
        if '&' in value or '/' in value:
            raise BFException(self, "& and / characters not allowed")
        if "`" in value or "‘" in value or "’‌" in value \
            or '"' in value or "”" in value or value.count("'") % 2 != 0:
            raise BFException(self, "Only use matched single quotes as 'string' delimiters")

    def _draw_body(self, context, layout):
        row = layout.row()
        row.prop(self.element, self.bpy_idname, text="", icon="TEXT")

    def format(self, context, value):
        return str(value) or None


### Specialized BFProp for geometry

class BFGeometryProp(BFProp):
    """This specialized BFProp is used as type for geometric parameters properties."""
    bpy_type = Object
    bpy_prop = EnumProperty
    allowed_items = "NONE", # list of allowed items for EnumProperty

    def _transform_layout(self, context, layout):
        split = layout.split(.1)
        col1, col2 = split.row(), split.column(align=True)
        col1.label(text="{}:".format(self.label))
        return col2
        
    def _draw_body(self, context, layout):
        # Draw enum with allowed items only
        row = layout.row(align=True)
        for item in self.allowed_items: row.prop_enum(self.element, self.bpy_idname, item)


class BFXBProp(BFGeometryProp):
    """This specialized BFProp is used as type for XB parameters properties."""
    label = "XB"
    description = "XB parameter for namelist geometry"
    fds_label = "XB"
    bpy_idname = "bf_xb"


class BFXYZProp(BFGeometryProp):
    """This specialized BFProp is used as type for XYZ parameters properties."""
    label = "XYZ"
    description = "XYZ parameter for namelist geometry"
    fds_label = "XYZ"
    bpy_idname = "bf_xyz"
       
        
class BFPBProp(BFGeometryProp):
    """This specialized BFProp is used as type for PB parameters properties."""   
    label = "PB*"
    description = "PB* parameter for namelist geometry"
    # fds_label = "PB" Inserted in format (like a free BFProp)
    bpy_idname = "bf_pb"
  
    
### Modifiers for derived BFProp

class BFNoAutoUIMod(): # No automatic UI (eg. my UI is managed elsewhere)
    def draw(self, context, layout):
        pass


class BFNoAutoExportMod(): # No automatic export (eg. my export is managed elsewhere)
    def to_fds(self, context):
        pass


class BFNoAutoImportMod(): # No automatic import (eg. my import is managed elsewhere)
    def from_fds(self, context):
        pass



